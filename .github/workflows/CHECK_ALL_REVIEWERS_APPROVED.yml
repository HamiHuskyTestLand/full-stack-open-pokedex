name: Check All Reviewers Approved

on:
  workflow_call:
    inputs:
      pr_number:
        required: true
        type: number
    outputs:
      all_approved:
        value: ${{ jobs.check-approvals.outputs.all_approved }}

jobs:
  check-approvals:
    runs-on: ubuntu-latest
    outputs:
      all_approved: ${{ steps.check.outputs.all_approved }}
    steps:
      - name: Check if all reviewers have approved
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber = ${{ inputs.pr_number }};
            
            const { data: pr } = await github.rest.pulls.get({ 
                owner, 
                repo, 
                pull_number: prNumber 
            });

            let allReviews = [];
            let page = 1;
            let hasMore = true;
            while (hasMore) {
                const { data } = await github.rest.pulls.listReviews({
                    owner, 
                    repo, 
                    pull_number: prNumber, 
                    per_page: 100, 
                    page: page++
                });
                allReviews.push(...data);
                hasMore = data.length === 100;
            }

            const latestReviewsByUser = allReviews.reduce(
                (acc, r) => ({ ...acc, [r.user.login]: r }), 
                {}
            );

            const humanReviews = Object.values(latestReviewsByUser).filter(r =>
                r.user. type !== 'Bot' 
                && !r.user.login.endsWith('[bot]')
            );

            const hasChangesRequested = humanReviews.some(r => 
                r.state === 'CHANGES_REQUESTED'
            );

            if (hasChangesRequested) {
                const requesters = humanReviews
                    .filter(r => r.state === 'CHANGES_REQUESTED')
                    .map(r => r.user.login);
                console.log('=== Stage 1: Has Changes Requested ===');
                console.log('❌ Changes requested by:', requesters);
                core.setOutput('all_approved', false);
                return;
            }

            console.log('=== Stage 1: No Changes Requested ===');
            console.log('✅ No one has requested changes\n');

            let allTimelineEvents = [];
            page = 1;
            hasMore = true;
            while (hasMore) {
                const { data } = await github.rest.issues.listEventsForTimeline({
                    owner, 
                    repo, 
                    issue_number: prNumber, 
                    per_page: 100, 
                    page: page++
                });
                allTimelineEvents.push(...data);
                hasMore = data.length === 100;
            }

            const allEverRequestedReviewers = new Set(
                pr.requested_reviewers
                    .filter(r => r.type !== 'Bot' && !r.login.endsWith('[bot]'))
                    .map(r => r.login)
            );
            
            allTimelineEvents.forEach(e => {
                if (e.event === 'review_requested' && e.requested_reviewer) {
                    const login = e.requested_reviewer.login;
                    if (e.requested_reviewer.type !== 'Bot' && !login.endsWith('[bot]')) {
                        allEverRequestedReviewers.add(login);
                    }
                }
            });

            if (allEverRequestedReviewers.size === 0) {
                core.setOutput('all_approved', false);
                return;
            }

            const hasPendingHumanReviewers = pr.requested_reviewers.some(r =>
                r.type !== 'Bot' 
                && !r.login.endsWith('[bot]')
            );

            const reviewerOnlyReviews = humanReviews.filter(r =>
                allEverRequestedReviewers.has(r.user.login)
            );

            const allReviewersApproved =
                reviewerOnlyReviews.filter(r => r.state === 'APPROVED').length > 0
                && !hasPendingHumanReviewers
                && reviewerOnlyReviews.every(r => r.state === 'APPROVED');

            core.setOutput('all_approved', allReviewersApproved);
